print（’hello‘）
hello
hello
a+b
a = 1
b = 2
a+b
shiny::runApp('Documents/R_project/fluktuationsanalyse')
shiny::runApp('Documents/Merseburg/Masterarbeit/R_Code')
install.packages(Rcpp >= 0.12.18)
install.packages(Rcpp>=0.12.18)
install.packages("Rcpp>=0.12.18")
shiny::runApp('Documents/Merseburg/Masterarbeit/R_Code')
install.packages("installr")
require(installr)
updateR()
update.packages()
install.packages("ggplot2", lib="/data/Rpackages/")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
remove.packages(c("ggplot2", "data.table"))
install.packages('Rcpp', dependencies = TRUE)
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
setwd("/Users/xinxin/Documents/Merseburg/Masterarbeit/Novel-Stream-Regression-shiny-app-")
getwd()
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
library(tidyverse)
library(caret)
# income dataset
# Earning and Education
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
View(dt)
sum(dt[WHRS==0])
sum(dt[WHRS]==0)
sum(dt["WHRS2]==0)
""
f
sum(dt["WHRS"]==0)
sum(dt["WHRS"]==0)
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
dt <-  dt["WHRS"]==0
dt$WHRS !=0
dt$WHRS
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
dt <-  dt$WHRS !=0
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
=
dt <- dt[dt[WHRS] != 0,]
dt <- dt[dt["WHRS"] != 0,]
View(dt)
incomeDT =  dt[2:7]
# add variable: woman income,in 1975 dollars
WINC = dt$WHRS*dt$WW
incomeDT["WINC"] = WINC
#add variable: Children = a dummy variable = 1 if woman had childre, else 0
incomeDT <- transform(incomeDT, Children=ifelse(KL6== 0  & K618== 0,0,1))
View(dt)
View(incomeDT)
income =  incomeDT %>% select(4,5,7,8)
income["WA2"] = (income$WA)^2
income["WA2"] = (income$WA)^2
income["WA2"] = (income$WA)^2
View(income)
income_model = lm( WINC ~ WE+ WA +WA2+ factor(Children),nor_income )
income_model = lm( WINC ~ WE+ WA +WA2+ factor(Children),income )
print(sprintf("MSE=%0.3f",  mean(income_model$residuals^2)))
car::vif(income_model)
cor(income)
car::vif(income_model)
cor(income)
xtable(cor(income),latex)
xtable(cor(income),latex)
xtable(cor(income),"latex")
library(DT)
library(shiny)
library(readxl)
library(ggplot2)
library(stringr)
library(dplyr)
library(data.table)
library(stringr)
library(zoo)
library(Matrix)
library(xtable)
# load package
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(htmlTable)
library(car)
library(stargazer)
library(gridExtra)
library(olsrr)
library(readr)
xtable(cor(income),"latex")
xtable(cor(income %>% select(1,2,4)),"latex")
income_model = lm( WINC ~ WE+ WA + WA2+ factor(Children),income )
print(sprintf("MSE=%0.3f",  mean(income_model$residuals^2)))
car::vif(income_model)
summary(income_model)
coef(income_model)
income_model = lm( WINC ~ WE+ WA + WA2+ factor(Children),income)
stargazer(income_model, model2, model3, title="Regression Results", align=TRUE)
car::vif(income_model)
summary(income_model)
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
nor_income = normalize(income)
income_model = lm( WINC ~ WE+ WA + WA2+ factor(Children),nor_income )
print(sprintf("MSE=%0.3f",  mean(income_model$residuals^2)))
car::vif(income_model)
summary(income_model)
coef(income_model)
setwd("/Users/xinxin/Documents/Merseburg/Masterarbeit/Novel-Stream-Regression-shiny-app-")
getwd()
# library
library(DT)
library(shiny)
library(readxl)
library(ggplot2)
library(stringr)
library(dplyr)
library(data.table)
library(stringr)
library(zoo)
library(Matrix)
library(xtable)
# load package
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(htmlTable)
library(car)
library(stargazer)
library(gridExtra)
library(olsrr)
library(readr)
#-----------------------------------------------------------------------------------------
#TASK ONE: load the data
#-----------------------------------------------------------------------------------------
# dataset1: money data
geld2 <- read_excel("data/geld2.xlsx", col_types = c("text", "numeric", "numeric", "numeric"), skip = 11)
# Y Bruttosozialprodukt, M1 MassfuerGeldmenge, P Preisbereinigungsindex
# dataset2: oek data
oekkennzd <- read_excel("data/oekkennzd.xlsx", col_types = c("text", "numeric", "numeric", "numeric", "numeric"), skip = 12)
# dataset3: simulation
simulation_data <- function(n,beta0,beta1,beta2)
{
# simulation regression data
set.seed(23)
# beta0 = 1
# beta1 = 2
# beta2= -2
x1 = runif(n, min = 0, max = 10000)
x2 = runif(n, min = 0, max = 999)
error =  rnorm(n)
y = beta0 + beta1*x1+ beta2*x2 + error
simlationDT = data.frame(y,x1,x2)
return(simlationDT)
}
# data set 1: data size =1000
simulationDT_1 = rbind(simulation_data(400,1,2,-2), simulation_data(600,4,2,-3))
# data set 2: data size = 10000
temp_2.1 = rbind(simulationDT_1, simulation_data(2000,3,5,-2))
temp_2.2 = rbind(simulation_data(3000,-2,3,-10), simulation_data(4000,3,5,-2))
simulationDT_2 = rbind(temp_2.1, temp_2.2)
# data set 3: data size = 1000000
temp_3.1 = rbind(simulationDT_2, simulation_data(20000,7,1,-2))
temp_3.2 = rbind(simulation_data(20000,4,-0.5,-2), simulation_data(20000,23,5,-2))
temp_3.3 = rbind(simulation_data(10000,3,-0.6,-6), simulation_data(20000,0.11,3,5))
simulationDT_3 = rbind(temp_3.1,temp_3.2)
simulationDT_3 = rbind(simulationDT_3,temp_3.3)
#-----------------------------------------------------------------------------------------
#TASK two: Format the data
#-----------------------------------------------------------------------------------------
# regression with seasonaility (just for dataset 1)
# convert data in Quarter
geld <- str_split_fixed(geld2$Quartal,fixed("-"),2)
colnames(geld) <- c("Year", "Quarter")
Q_Geld <- cbind(geld, geld2[,2:4])
oekkennzd = data.frame(oekkennzd)
# Normalization the money
Q_Geld = Q_Geld %>% mutate_at(c("Y", "M1","P"), ~(scale(.) %>% as.vector))
# Normalization the oekk.
oekkennzd = oekkennzd %>% mutate_at(c("SP", "CPI","ULC"), ~(scale(.) %>% as.vector))
#-----------------------------------------------------------------------------------------
#TASK three: preprocessing the data for analysing
#-----------------------------------------------------------------------------------------
# set the money data
x0 = rep(1, nrow(Q_Geld))
X = as.matrix (cbind(x0, Q_Geld[,4:5]))
y= as.matrix(Q_Geld[,3])
#set the oekk
DS2_x0 = rep(1, nrow(oekkennzd))
DS2_X =as.matrix(cbind(DS2_x0,oekkennzd[,3:5]))
DS2_y= as.matrix(oekkennzd[,2])
# set the simulationsdata
DS3_x0 = rep(1, nrow(simulationDT_1))
DS3_X =as.matrix(cbind(DS3_x0,simulationDT_1[,2:3]))
DS3_y= as.matrix(simulationDT_1[,1])
# size 10000
sim2_DS3_x0 = rep(1, nrow(simulationDT_2))
sim2_DS3_X =as.matrix(cbind(sim2_DS3_x0,simulationDT_2[,2:3]))
sim2_DS3_y= as.matrix(simulationDT_2[,1])
#size 100000
sim3_DS3_x0 = rep(1, nrow(simulationDT_3))
sim3_DS3_X =as.matrix(cbind(sim3_DS3_x0,simulationDT_3[,2:3]))
sim3_DS3_y= as.matrix(simulationDT_3[,1])
#---------------------------------
# regression model
#---------------------------------
# Init mutilple model
money_model  = Y~ M1 + P
oekk_model = IR ~ SP+ CPI + ULC
simu_model = y ~ x1 + x2
# multiple regression model
model1 = lm (money_model ,data = Q_Geld)
model2 = lm (oekk_model ,oekkennzd)
model3 = lm (simu_model ,simulationDT_1)
#mse
print(sprintf("MSE=%0.3f",  mean(model1$residuals^2)))
print(sprintf("MSE=%0.3f",  mean(model2$residuals^2)))
print(sprintf("MSE=%0.2f",  mean(model3$residuals^2)))
# output the latex table
#stargazer(model1, model2, model3, title="Regression Results", align=TRUE)
#----------------------------------
# multicollinearity
#---------------------------------
car::vif(model1)
car::vif(model2)
car::vif(model3)
# correlation
Q_dat = Q_Geld[3:5]
cor(Q_dat)
cor(oekkennzd[3:5])
cor(simulationDT_1)
cor(simulationDT_2)
cor(simulationDT_3)
stargazer(income_model, model2, model3, title="Regression Results", align=TRUE)
runApp('~/Downloads/Shiny-App--master')
runApp()
coef(income_model)
stargazer(model2, model3, income_model title="Regression Results", align=TRUE)
stargazer(model2, model3, income_model, title="Regression Results", align=TRUE)
(sprintf("MSE=%0.3f",  mean(income_model$residuals^2)))
# income dataset
# Earning and Education
dt  <- read_table2("data/TableF4-1.txt", skip = 27)
#choosing the data,which were participants in the formal labor market
dt <- dt[dt["WHRS"] != 0,]
incomeDT =  dt[2:7]
# add variable: woman income,in 1975 dollars
WINC = dt$WHRS*dt$WW
incomeDT["WINC"] = WINC
#add variable: Children = a dummy variable = 1 if woman had childre, else 0
incomeDT <- transform(incomeDT, Children=ifelse(KL6== 0  & K618== 0,0,1))
View(incomeDT)
income =  incomeDT %>% select(4,5,7,8)
View(income)
View(incomeDT)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(oekkennzd)
runApp()
timeStream(earing, 5,earning_model)
timeStream<- function (DS, m, Md)
{
#print(paste0("Total data blocks: ", m))
# getting the column names of data set
colNames = names(DS)
# getting the number of columns in the data set
numCol = ncol(DS)
#print(paste0("Total data rows: ", nrow(DS)))
# n is the sample size of each block (or how many rows a block contains)
n = nrow(DS)/m
# first block
model = lm (Md, data = DS[1:n,])
# beta coefficient of first block
beta= model$coefficients
# initialize a empty beta matrix
coefIter <- matrix(NA, nrow = ncol(DS), ncol = m)
coefIter[,1]= beta
# initialize a empty X matrix
X_new = data.frame(matrix(NA, ncol = ncol(DS)-1, nrow = n))
for (i in 2:m) {
DT <-DS[((i-1)*n+1): (n*i),] # all cols
y_new = DT[,1]
# updating the new X
for (j in 1:n)
{
x_new = j*DT[j,2:numCol]
X_new[j,] = x_new
}
# combine the y and X variables
newDS = cbind(y_new,X_new)
# changing the column names of new data set
colnames(newDS) = colNames
# setting a new model
fit.model = lm(Md, data = newDS)
summary = summary(fit.model)
#getting the coef.
coef = fit.model$coefficients
coefIter[,i] = coef
rownames(coefIter) <- c("(Intercept)", colnames(DS)[2:ncol(DS)])
#mse
mse =  mean(fit.model$residuals^2)
# stores the summary of the model and the coefficients
result <- list("summary"=summary, "coef" = coefIter )
}
return (result)
}
timeStream(earning, 5,earning_model)
timeStream(earning, 5,earning_model)
timeStream<- function (DS, m, Md)
{
#print(paste0("Total data blocks: ", m))
# getting the column names of data set
colNames = names(DS)
# getting the number of columns in the data set
numCol = ncol(DS)
#print(paste0("Total data rows: ", nrow(DS)))
# n is the sample size of each block (or how many rows a block contains)
n = nrow(DS)/m
# first block
model = lm (Md, data = DS[1:n,])
# beta coefficient of first block
beta= model$coefficients
# initialize a empty beta matrix
coefIter <- matrix(NA, nrow = ncol(DS), ncol = m)
coefIter[,1]= beta
# initialize a empty X matrix
X_new = data.frame(matrix(NA, ncol = ncol(DS)-1, nrow = n))
for (i in 2:m) {
DT <-DS[((i-1)*n+1): (n*i),] # all cols
y_new = DT[,1]
# updating the new X
for (j in 1:n)
{
x_new = j*DT[j,2:numCol]
X_new[j,] = x_new
}
# combine the y and X variables
newDS = cbind(y_new,X_new)
# changing the column names of new data set
colnames(newDS) = colNames
# setting a new model
fit.model = lm(Md, data = newDS)
summary = summary(fit.model)
#getting the coef.
coef = fit.model$coefficients
print(coef)
coefIter[,i] = coef
rownames(coefIter) <- c("(Intercept)", colnames(DS)[2:ncol(DS)])
#mse
mse =  mean(fit.model$residuals^2)
# stores the summary of the model and the coefficients
result <- list("summary"=summary, "coef" = coefIter )
}
return (result)
}
timeStream(earning, 5,earning_model)
runApp()
View(earning)
runApp()
income_model = lm( WINC ~ WE+ WA + WA2+ Children,earning )
print(sprintf("MSE=%0.3f",  mean(income_model$residuals^2)))
car::vif(income_model)
xtable(income[1:10,],"latex")
xtable(summary(income),"latex")
income_model = lm( WINC ~ WE+ WA + WA2+ Children,earning )
car::vif(income_model)
cor(earning)
cor(earning[,1,2,4])
cor(earning[1,2,4])
cor(earning[1:2,4])
cor(income %>% select(1,2,4))
stargazer(model2, model3, income_model, title="Regression Results", align=TRUE)
View(earning)
runApp()
streamMulti <- function(X,y,m,constant){
# get the column names
Colnames <- colnames(X)
# n is the sample size of each block (or how many rows a block contains)
n = nrow(X)/m
# initialize beta
init = 0
beta <- matrix(init,nrow = ncol(X),ncol = 1)
betaIter <- matrix(NA, nrow = ncol(X), ncol = m)
# initialize MSE
mseIter <- matrix(NA, nrow = m, ncol = 1)
# initialize R squared
rsqIter  <- matrix(NA, nrow = m, ncol = 1)
# initialize matrix
yhat <- matrix(init, nrow = 1, ncol = 1)
zhat <- matrix(init, nrow = ncol(X), ncol = 1)
z <- matrix(init, nrow = ncol(X), ncol = ncol(X))
# split the whole data into m blocks
for (i in 1:m) {
xsamp <-X[((i-1)*n+1): (n*i),]
ysamp = y[((i-1)*n+1): (n*i),]
message('Coming the block:',i)
#print('-------------------')
# determine the learning rate q
#print("Determin the value q")
if ( is.na(constant) ){
#print("initial q is not a constant")
N <- nrow(xsamp)*i
q <- n/N
} else {
#print("constant q")
q <- constant
}
message('q value: ', q)
# compute the z, zhat and yhat
z <- 1/n * q* (t(xsamp) %*% xsamp) + (1-q) * z
zhat <- 1/n * q* (t(xsamp) %*% ysamp) + (1-q) * zhat
yhat <- 1/n * q* (t(ysamp) %*% ysamp) + (1-q) *yhat
# update beta
betanew <-  solve(t(xsamp) %*% xsamp) %*% (t(xsamp) %*% ysamp)
beta <- betanew
message('beta is:',beta)
# update the minimization of mse
mse <- yhat - 2*( t(beta) %*% zhat) +(t(beta)%*%z %*%beta)
message('mse is:', mse)
# residual sum of squares
rss <- nrow(X)*mse
# total sum of squares
tss <- sum(y- mean(y)^2)
# R-Squared
rsq <- 1- (rss/tss)
mseIter[i,] <- mse
betaIter[,i] <- beta
rsqIter[i,] <- rsq
}
# change the rownames of the cofficients
rownames(betaIter) <- c("(Intercept)", Colnames[2:ncol(X)])
colnames(betaIter) <- paste0("Block", 1:ncol(betaIter))
# create a data table for storing the MSE and R-Squared
dt <-setNames(data.table(matrix(nrow = m, ncol = 3)), c("Block", "MSE", "R.Squared"))
dt$"Block" <- 1:m
dt$"MSE" <- mseIter
dt$"R.Squared" <-rsqIter
# stores the mse and the parameters
result <- list('Coefficients'= betaIter,'summary'= dt)
return(result)
}
streamMulti(earning_x,earning_y,5,0.01)
runApp()
runApp()
runApp()
runApp()
income_model = lm( WINC ~ WE+ WA + WA2+ Children,earning )
print(income_model$coef)
summary(income_model)
summary(income_model)$coef
res = summary(income_model)$coef
res[1]
res = summary(income_model)$coef
res[Estimate]
res["Estimate"]
res = summary(income_model)$coef
res["Estimate"]
["Estimate"]
res
r =data.frame(res)
r
r =data.frame(res)[1]
r
runApp()
runApp()
runApp()
runApp()
